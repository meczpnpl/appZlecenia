<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <meta name="description" content="System zarzÄ…dzania zleceniami dla Bel-Pol" />
    <meta name="theme-color" content="#2563eb" />
    <title>Bel-Pol System ZarzÄ…dzania Zleceniami v2.0.3</title>
    <!-- Wymuszenie odÅ›wieÅ¼enia zasobÃ³w - przeciwko cachowaniu -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link rel="manifest" href="/manifest.json?v=2.0.3" crossorigin="use-credentials" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232563eb'%3E%3Cpath d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5'%3E%3C/path%3E%3C/svg%3E" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PWA support -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bel-Pol">
    <link rel="apple-touch-icon" href="/icon-192x192.png?v=2.0.1">
    <link rel="shortcut icon" href="/icon-192x192.png?v=2.0.1">
    
    <!-- Style, aby upewniÄ‡ siÄ™, Å¼e podpowiedzi Google sÄ… klikalne -->
    <style>
      /* Style aby Google Maps Autocomplete byÅ‚o klikalne */
      .pac-container {
        z-index: 99999 !important;
        background-color: white !important;
        border: 1px solid #ccc !important;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
        position: absolute !important;
        overflow: visible !important;
        pointer-events: auto !important;
        display: block !important;
        opacity: 1 !important;
        width: auto !important;
        min-width: 300px !important;
        transform: translateY(5px) !important;
      }
      
      .pac-item {
        cursor: pointer !important;
        padding: 12px !important;
        margin: 5px 0 !important;
        border-top: 1px solid #e6e6e6 !important;
        font-size: 16px !important;
        font-weight: bold !important;
        color: #333 !important;
        display: block !important;
        pointer-events: auto !important;
      }
      
      .pac-item:hover,
      .pac-item-selected,
      .pac-item:focus {
        background-color: #4285f4 !important;
        color: white !important;
        outline: none !important;
      }
      
      /* Style dla kontenera podpowiedzi */
      .pac-container {
        border-radius: 6px !important;
      }
    </style>
    
    <!-- NarzÄ™dzia diagnostyczne -->
    <script>
      // Funkcja wymuszajÄ…ca odÅ›wieÅ¼enie cache
      (function() {
        // Wymuszamy odÅ›wieÅ¼enie cache gdy mamy wersjÄ™ w parametrze URL
        if (window.location.href.indexOf('v=') === -1) {
          // Dodaj wersjÄ™ jako parametr do URL
          const newUrl = window.location.href + (window.location.href.indexOf('?') === -1 ? '?' : '&') + 'v=' + Date.now();
          
          // Przekieruj do nowego URL
          window.location.href = newUrl;
          return;
        }
        
        // Zapisz wersjÄ™ w localStorage aby sprawdziÄ‡, czy jest aktualna
        const currentVersion = '2.0.1';
        const savedVersion = localStorage.getItem('bel_pol_version');
        
        if (savedVersion !== currentVersion) {
          console.log('Wykryto nowÄ… wersjÄ™ aplikacji. Wymuszam odÅ›wieÅ¼enie cache.');
          
          // UsuÅ„ wszystkie elementy z cache
          if ('caches' in window) {
            caches.keys().then(function(names) {
              for (let name of names) {
                caches.delete(name);
              }
            });
          }
          
          // Wyrejestruj service worker, aby zastosowaÄ‡ nowy
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
              for (let registration of registrations) {
                registration.unregister();
                console.log('Wyrejestrowano service worker');
              }
            });
          }
          
          // Zapisz nowÄ… wersjÄ™
          localStorage.setItem('bel_pol_version', currentVersion);
          
          // Hard reload
          window.location.reload(true);
        }
      })();

      // Funkcja do debugowania zdarzeÅ„
      window.debugGoogleMapsEvents = function() {
        console.log("Podpinanie diagnostyki do zdarzeÅ„ Google Maps");
        
        // Monitoruj zmiany DOM, aby wykryÄ‡ dodanie kontenera z podpowiedziami
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
              for (let i = 0; i < mutation.addedNodes.length; i++) {
                const node = mutation.addedNodes[i];
                if (node.nodeType === 1) { // Element node
                  // SprawdÅº, czy to element HTML
                  if (node instanceof HTMLElement) {
                    // SprawdÅº, czy to kontener podpowiedzi Google
                    if (node.classList && node.classList.contains('pac-container')) {
                      console.log('DIAGNOSTYKA: Wykryto kontener pac-container!', node);
                      
                      // Dodaj delikatne podÅ›wietlenie dla lepszej widocznoÅ›ci
                      node.style.border = '1px solid #ccc';
                      node.style.zIndex = '99999';
                      
                      // SprawdÅº styl pozycjonowania
                      const computedStyle = window.getComputedStyle(node);
                      console.log('DIAGNOSTYKA: Style kontenera:', {
                        position: computedStyle.position,
                        zIndex: computedStyle.zIndex,
                        display: computedStyle.display,
                        visibility: computedStyle.visibility,
                        pointerEvents: computedStyle.pointerEvents
                      });
                      
                      // Dodaj handlers zdarzeÅ„ do wszystkich elementÃ³w wewnÄ…trz
                      const pacItems = node.querySelectorAll('.pac-item');
                      for (let j = 0; j < pacItems.length; j++) {
                        const item = pacItems[j];
                        console.log(`DIAGNOSTYKA: Znaleziono element .pac-item ${j}`, item);
                        
                        // Dodaj klikalne style
                        if (item instanceof HTMLElement) {
                          item.style.cursor = 'pointer';
                          item.style.padding = '10px';
                          
                          // Dodaj manual click handler
                          item.addEventListener('click', function(e) {
                            console.log('DIAGNOSTYKA: KlikniÄ™to na element .pac-item', this);
                          });
                          
                          item.addEventListener('mouseenter', function() {
                            console.log('DIAGNOSTYKA: Najechano na element .pac-item', this);
                          });
                        }
                      }
                    }
                  }
                }
              }
            }
            
            // Dodatkowa diagnostyka - sprawdÅº wszystkie kontenery pac-container w dokumencie
            const allPacContainers = document.querySelectorAll('.pac-container');
            if (allPacContainers.length > 0) {
              console.log('DIAGNOSTYKA: Wszystkie kontenery .pac-container w dokumencie:', allPacContainers);
            }
          });
        });
        
        // Obserwuj zmiany w caÅ‚ym dokumencie
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        
        // Dodaj diagnostykÄ™ do globalnego inicjalizatora
        const originalInit = window.initGoogleAddressAutocomplete;
        window.initGoogleAddressAutocomplete = function(inputId, options) {
          console.log('DIAGNOSTYKA: WywoÅ‚ano initGoogleAddressAutocomplete dla', inputId);
          const result = originalInit(inputId, options);
          
          if (result) {
            console.log('DIAGNOSTYKA: PomyÅ›lnie utworzono Autocomplete', result);
            
            // Podepnij dodatkowe nasÅ‚uchiwanie
            google.maps.event.addDomListener(document.getElementById(inputId), 'keydown', function(e) {
              console.log('DIAGNOSTYKA: Keydown na input', e.keyCode);
              
              // SprawdÅº czy klawisz Enter lub strzaÅ‚ki sÄ… wciskane (mogÄ… byÄ‡ zwiÄ…zane z wyborem sugestii)
              if (e.keyCode === 13 || (e.keyCode >= 37 && e.keyCode <= 40)) {
                console.log('DIAGNOSTYKA: WciÅ›niÄ™to klawisz nawigacji lub Enter');
              }
            });
          }
          
          return result;
        };
        
        console.log("Diagnostyka Google Maps zainicjalizowana");
      };
      
      // Uruchom diagnostykÄ™ po zaÅ‚adowaniu strony
      window.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (window.google && window.google.maps) {
            window.debugGoogleMapsEvents();
          } else {
            console.log('DIAGNOSTYKA: Google Maps jeszcze nie zaÅ‚adowane');
          }
        }, 2000);
      });
    </script>
    
    <!-- Dodajemy Google Maps API bezpoÅ›rednio w gÅ‚Ã³wnym pliku HTML -->
    <script>
      // Dodajemy rÄ™czne zaÅ‚atwienie problemu z klikaniem w podpowiedzi Google Maps
      document.addEventListener('click', function(event) {
        const target = event.target;
        
        // ObsÅ‚uga klikniÄ™Ä‡ w podpowiedzi Google Maps
        if (target instanceof HTMLElement && 
           (target.classList.contains('pac-item') || 
            target.closest('.pac-item') || 
            target.closest('.pac-container'))) {
            
          console.log('ROZWIÄ„ZANIE: ZÅ‚apano klikniÄ™cie na element podpowiedzi!', target);
          
          // Zapobiegamy zamkniÄ™ciu dialogÃ³w (w tym okna dodawania sklepu)
          event.stopPropagation();
          
          // SprÃ³buj wyciÄ…gnÄ…Ä‡ tekst adresu z podpowiedzi
          let addressText = '';
          if (target.textContent) {
            addressText = target.textContent.trim();
          }
          
          // ZnajdÅº najbliÅ¼szy input z adresem (prawdopodobnie ten, ktÃ³ry ma focus)
          const inputs = document.querySelectorAll('input[id^="address-input-"]');
          let activeInput = null;
          
          for (let i = 0; i < inputs.length; i++) {
            if (document.activeElement === inputs[i]) {
              activeInput = inputs[i];
              break;
            }
          }
          
          if (activeInput && addressText) {
            console.log('ROZWIÄ„ZANIE: Znaleziono aktywny input:', activeInput.id);
            console.log('ROZWIÄ„ZANIE: Ustawianie wartoÅ›ci adresu:', addressText);
            
            // Ustaw wartoÅ›Ä‡ w polu
            activeInput.value = addressText;
            
            // WywoÅ‚aj zdarzenie zmiany wartoÅ›ci
            const inputEvent = new Event('input', { bubbles: true });
            activeInput.dispatchEvent(inputEvent);
            
            // WywoÅ‚aj zdarzenie niestandardowe
            const customEvent = new CustomEvent('autocomplete_place_selected', { 
              detail: { 
                place: { formatted_address: addressText }, 
                inputId: activeInput.id 
              }
            });
            document.dispatchEvent(customEvent);
            
            // UsuÅ„ caÅ‚kowicie wszystkie kontenery podpowiedzi
            const allPacContainers = document.querySelectorAll('.pac-container');
            allPacContainers.forEach(container => {
              if (container && container.parentNode) {
                container.parentNode.removeChild(container);
              }
            });
          }
        }
      }, true); // UÅ¼ywamy przechwytywania zdarzeÅ„, aby zÅ‚apaÄ‡ je przed innymi handlerami
      
      function initializeGoogleMapsAddressAutocomplete() {
        // Ta funkcja bÄ™dzie dostÄ™pna globalnie
        window.initGoogleAddressAutocomplete = function(inputId, options = {}) {
          console.log("Inicjalizacja Google Autocomplete dla:", inputId);
          const input = document.getElementById(inputId);
          if (!input) {
            console.error("Nie znaleziono elementu input o ID:", inputId);
            return null;
          }
          
          // DomyÅ›lne opcje
          const defaultOptions = { 
            componentRestrictions: { country: 'pl' },
            types: ['address'],
            fields: ['formatted_address', 'geometry', 'name', 'address_components']
          };
          
          // ÅÄ…czymy z opcjami uÅ¼ytkownika
          const autocompleteOptions = { ...defaultOptions, ...options };
          
          try {
            // Tworzymy autocomplete
            const autocomplete = new google.maps.places.Autocomplete(input, autocompleteOptions);
            console.log("Autocomplete zostaÅ‚o utworzone pomyÅ›lnie");
            
            // Dodajemy event listener bezpoÅ›rednio w gÅ‚Ã³wnym skrypcie (uÅ¼ywamy addEventListener zamiast event.addListener)
            autocomplete.addListener('place_changed', function() {
              console.log("Wykryto zmianÄ™ miejsca w autocomplete");
              const place = autocomplete.getPlace();
              if (place && place.formatted_address) {
                console.log("Wybrano adres:", place.formatted_address);
                
                // Wyzwalamy niestandardowe zdarzenie, ktÃ³re zostanie obsÅ‚uÅ¼one w komponencie
                const event = new CustomEvent('autocomplete_place_selected', { 
                  detail: { place: place, inputId: inputId }
                });
                document.dispatchEvent(event);
                
                // UsuÅ„ caÅ‚kowicie wszystkie kontenery podpowiedzi
                const allPacContainers = document.querySelectorAll('.pac-container');
                allPacContainers.forEach(container => {
                  if (container && container.parentNode) {
                    container.parentNode.removeChild(container);
                  }
                });
              }
            });
            
            return autocomplete;
          } catch (err) {
            console.error("BÅ‚Ä…d podczas tworzenia autocomplete:", err);
            return null;
          }
        }
      }
    </script>
    <script 
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBmVOvP_KNpynR7Y1NZsUQ9vh6zrVD6Zos&libraries=places&callback=initializeGoogleMapsAddressAutocomplete&loading=async" 
      defer
    ></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
    
    <!-- Skrypt obsÅ‚ugujÄ…cy bezpoÅ›rednie URL i rÃ³Å¼ne domeny -->
    <script>
      // Funkcja do naprawy WebSocket HMR dla Vite przy rÃ³Å¼nych domenach (V2.0)
      function fixWebSocketConnection() {
        console.log("InstalujÄ™ poprawkÄ™ WebSocket v2.0");
        // ZastÄ…pmy standardowe WebSocket aby naprawiÄ‡ poÅ‚Ä…czenia
        const OriginalWebSocket = window.WebSocket;
        
        window.WebSocket = function(url, protocols) {
          // Zabezpieczenie przed pustym lub nieprawidÅ‚owym URL
          if (!url || typeof url !== 'string') {
            console.warn("NieprawidÅ‚owy URL WebSocket:", url);
            // Zwracamy mock WebSocket zamiast wyrzucania bÅ‚Ä™du
            return getMockWebSocket();
          }
          
          // Naprawiamy wszystkie URL do WebSocket
          console.log("Przechwycono prÃ³bÄ™ poÅ‚Ä…czenia WebSocket:", url);
          
          try {
            // Przypadek 1: PrÃ³ba poÅ‚Ä…czenia z localhost:undefined - bÅ‚Ä™dny port
            if (url.includes('localhost:undefined')) {
              console.log("ðŸ”´ Naprawianie bÅ‚Ä™dnego URL z localhost:undefined");
              // UÅ¼ywamy aktualnego hosta i protokoÅ‚u
              const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
              const token = url.includes('token=') ? url.split('token=')[1].split('&')[0] : '';
              const tokenPart = token ? `?token=${token}` : '';
              const newUrl = `${protocol}//${window.location.host}/${tokenPart}`;
              console.log("âœ… Poprawiony URL:", newUrl);
              return new OriginalWebSocket(newUrl, protocols);
            }
            
            // Przypadek 2: Gdy peÅ‚ny URL jest nieprawidÅ‚owy (np. brakuje protokoÅ‚u)
            if (!/^(wss?|https?):\/\//.test(url)) {
              console.log("ðŸ”´ NieprawidÅ‚owy format URL (brak protokoÅ‚u)");
              const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
              
              // Zachowujemy Å›cieÅ¼kÄ™, ktÃ³ra moÅ¼e zawieraÄ‡ informacje o HMR
              let path = '/';
              // JeÅ›li URL zaczyna siÄ™ od / to jest to Å›cieÅ¼ka
              if (url.startsWith('/')) {
                path = url;
              }
              
              const newUrl = `${protocol}//${window.location.host}${path}`;
              console.log("âœ… Dodano protokÃ³Å‚:", newUrl);
              return new OriginalWebSocket(newUrl, protocols);
            }
            
            // Przypadek 3: Gdy WebSocket musi dziaÅ‚aÄ‡ z innej domeny niÅ¼ skrypt
            const currentDomain = window.location.hostname;
            if (!url.includes(currentDomain)) {
              console.log("ðŸ”´ Wykryto prÃ³bÄ™ poÅ‚Ä…czenia z innÄ… domenÄ…:", url);
              const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
              
              // WyciÄ…gamy Å›cieÅ¼kÄ™ z oryginalnego URL jeÅ›li jest
              let path = '/';
              try {
                const urlObj = new URL(url);
                path = urlObj.pathname || '/';
                console.log("WyciÄ…gniÄ™ta Å›cieÅ¼ka z URL:", path);
              } catch (e) {
                console.log("Nie moÅ¼na sparsowaÄ‡ URL, uÅ¼ywam /");
              }
              
              // WyciÄ…gamy token jeÅ›li istnieje
              const token = url.includes('token=') ? url.split('token=')[1].split('&')[0] : '';
              // Tworzymy parametr tokena z ? lub & w zaleÅ¼noÅ›ci czy Å›cieÅ¼ka juÅ¼ ma parametry
              const hasParams = path.includes('?');
              const tokenPart = token ? `${hasParams ? '&' : '?'}token=${token}` : '';
              
              const newUrl = `${protocol}//${window.location.host}${path}${tokenPart}`;
              console.log("âœ… UÅ¼ywam lokalnego WebSocket URL:", newUrl);
              return new OriginalWebSocket(newUrl, protocols);
            }
            
            // Przypadek 4: URL zawiera nieprawidÅ‚owy port (dla Replit zawsze uÅ¼ywamy domyÅ›lnego portu)
            if (url.includes(currentDomain) && /:[0-9]+\//.test(url)) {
              console.log("ðŸ”´ URL zawiera port, ktÃ³ry moÅ¼e byÄ‡ nieprawidÅ‚owy na Replit");
              const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
              const token = url.includes('token=') ? url.split('token=')[1].split('&')[0] : '';
              const tokenPart = token ? `?token=${token}` : '';
              const newUrl = `${protocol}//${window.location.host}/${tokenPart}`;
              console.log("âœ… UÅ¼ywam URL bez portu:", newUrl);
              return new OriginalWebSocket(newUrl, protocols);
            }
            
            // JeÅ›li Å¼aden z powyÅ¼szych przypadkÃ³w nie pasuje, uÅ¼ywamy oryginalnego URL
            return new OriginalWebSocket(url, protocols);
            
          } catch (err) {
            console.error("BÅ‚Ä…d podczas naprawiania WebSocket:", err);
            
            // SprÃ³bujmy uÅ¼yÄ‡ bezpiecznego URL jako fallback
            try {
              const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
              const fallbackUrl = `${protocol}//${window.location.host}/`;
              console.log("âš ï¸ UÅ¼ywam fallback URL:", fallbackUrl);
              return new OriginalWebSocket(fallbackUrl, protocols);
            } catch (e) {
              console.error("Nie udaÅ‚o siÄ™ utworzyÄ‡ WebSocket fallback:", e);
              return getMockWebSocket();
            }
          }
        };
        
        // Helper function to create a mock WebSocket
        function getMockWebSocket() {
          const mockSocket = {
            readyState: 3, // CLOSED
            send: function() { console.warn("PrÃ³ba wysÅ‚ania przez zamkniÄ™ty WebSocket"); },
            close: function() { console.warn("PrÃ³ba zamkniÄ™cia zamkniÄ™tego WebSocket"); },
            addEventListener: function(event, callback) { 
              console.warn(`PrÃ³ba dodania nasÅ‚uchiwania '${event}' do zamkniÄ™tego WebSocket`);
            },
            removeEventListener: function(event, callback) {
              console.warn(`PrÃ³ba usuniÄ™cia nasÅ‚uchiwania '${event}' z zamkniÄ™tego WebSocket`);
            }
          };
          
          // Dodajemy odpowiednie event handlery jako wÅ‚aÅ›ciwoÅ›ci
          mockSocket.onopen = null;
          mockSocket.onclose = null;
          mockSocket.onerror = null;
          mockSocket.onmessage = null;
          
          return mockSocket;
        }
        
        // Zachowujemy wÅ‚aÅ›ciwoÅ›ci i staÅ‚e z oryginalnej klasy WebSocket
        window.WebSocket.prototype = OriginalWebSocket.prototype;
        window.WebSocket.CONNECTING = OriginalWebSocket.CONNECTING;
        window.WebSocket.OPEN = OriginalWebSocket.OPEN;
        window.WebSocket.CLOSING = OriginalWebSocket.CLOSING;
        window.WebSocket.CLOSED = OriginalWebSocket.CLOSED;
        
        console.log("Naprawa WebSocket zainstalowana");
      }
      
      // Wykonaj naprawÄ™ WebSocketÃ³w od razu
      fixWebSocketConnection();
    
      // Funkcja do wykrywania i naprawiania problemÃ³w z routingiem
      function initUrlFixer() {
        console.log("BEL-POL URL Fixer - uruchomiony");
        
        // Diagnostyczne informacje o Å›rodowisku
        console.log("URL Info:", {
          current: window.location.href,
          host: window.location.host, 
          origin: window.location.origin,
          pathname: window.location.pathname
        });
  
        // Weryfikacja czy aplikacja jest zaÅ‚adowana poprawnie
        window.addEventListener('load', function() {
          console.log("BEL-POL URL Fixer - strona zaÅ‚adowana, weryfikujÄ™ zawartoÅ›Ä‡");
          
          // Funkcja pomocnicza do przechodzenia miÄ™dzy adresami
          window.handleManualNavigation = function(targetPath) {
            console.log("BEL-POL Navigation Helper - przekierowujÄ™ do:", targetPath);
            
            // Najpierw zapisujemy Å›cieÅ¼kÄ™ do lokalnego storage
            localStorage.setItem('bel_pol_last_path', targetPath);
            
            // Teraz przechodzimy do nowego URL
            window.location.href = window.location.origin + targetPath;
            
            // Zapobiegamy dalszemu wykonaniu funkcji
            return false;
          };
          
          // Sprawdzenie zawartoÅ›ci strony (po zaÅ‚adowaniu)
          setTimeout(function() {
            const appRoot = document.getElementById('root');
            const hasContent = appRoot && (appRoot.children.length > 0);
            
            console.log("BEL-POL URL Fixer - sprawdzam zawartoÅ›Ä‡: " + 
                        (hasContent ? "OK" : "PUSTA STRONA"));
            
            if (!hasContent) {
              console.log('Wykryto problem z Å‚adowaniem strony - prÃ³bujÄ™ naprawiÄ‡...');
              
              // SprÃ³buj najpierw okreÅ›liÄ‡, jaka powinna byÄ‡ wÅ‚aÅ›ciwa Å›cieÅ¼ka
              let targetPath = '/';
              
              // 1. SprawdÅº, czy mamy zapisanÄ… Å›cieÅ¼kÄ™ w localStorage
              const savedPath = localStorage.getItem('bel_pol_last_path');
              if (savedPath) {
                console.log('Znaleziono zapisanÄ… Å›cieÅ¼kÄ™:', savedPath);
                targetPath = savedPath;
              } 
              // 2. JeÅ›li nie, uÅ¼yj bieÅ¼Ä…cej Å›cieÅ¼ki
              else if (window.location.pathname !== '/') {
                targetPath = window.location.pathname;
              }
              
              // JeÅ›li jesteÅ›my na stronie gÅ‚Ã³wnej i wciÄ…Å¼ nie ma zawartoÅ›ci, sprÃ³bujmy przeÅ‚adowaÄ‡
              if (window.location.pathname === '/' && !hasContent) {
                console.log('JesteÅ›my juÅ¼ na stronie gÅ‚Ã³wnej, przeÅ‚adowujÄ™ stronÄ™');
                window.location.reload();
                return;
              }
              
              // Teraz przekieruj do strony gÅ‚Ã³wnej z parametrem redirect
              console.log('PrzekierowujÄ™ do strony gÅ‚Ã³wnej z parametrem redirect:', targetPath);
              window.location.href = window.location.origin + 
                                    '/?redirect=' + 
                                    encodeURIComponent(targetPath + window.location.search);
            }
          }, 3000); // Dajemy 3 sekundy na zaÅ‚adowanie aplikacji
        });
        
        // Po zaÅ‚adowaniu DOM, sprawdÅº czy mamy parametr redirect
        document.addEventListener('DOMContentLoaded', function() {
          console.log("BEL-POL URL Fixer - DOM zaÅ‚adowany, sprawdzam parametry URL");
          
          const urlParams = new URLSearchParams(window.location.search);
          const redirectPath = urlParams.get('redirect');
          
          if (redirectPath) {
            console.log('Wykryto parametr przekierowania, bÄ™dÄ™ nawigowaÄ‡ do:', redirectPath);
            
            // Czekamy chwilÄ™ na zaÅ‚adowanie aplikacji
            setTimeout(function() {
              try {
                // Zapisz do lokalnego storage Å›cieÅ¼kÄ™, do ktÃ³rej nawigujemy
                localStorage.setItem('bel_pol_last_path', redirectPath);
                
                // Zmieniamy URL bez przeÅ‚adowania strony
                window.history.replaceState(null, '', redirectPath);
                
                console.log('Przekierowanie wewnÄ™trzne wykonane');
                
                // WyzwÃ³l zdarzenie LocationChanged dla wouter
                window.dispatchEvent(new Event('pushstate'));
                window.dispatchEvent(new Event('popstate'));
              } catch (e) {
                console.error('BÅ‚Ä…d podczas przekierowania:', e);
              }
            }, 300);
          }
        });
      }
      
      // Uruchom system naprawy URL
      initUrlFixer();
      
      // PodpiÄ™cie nasÅ‚uchiwania zdarzeÅ„ dla elementÃ³w menu i przyciskÃ³w nawigacyjnych
      document.addEventListener('DOMContentLoaded', function() {
        // NasÅ‚uchujemy klikniÄ™Ä‡ na elementach <a>
        document.body.addEventListener('click', function(e) {
          let targetEl = e.target;
          
          // Sprawdzamy, czy klikniÄ™ty element lub jego rodzic jest linkiem <a>
          while (targetEl && targetEl !== document.body) {
            if (targetEl.tagName === 'A' && targetEl.hasAttribute('href')) {
              const href = targetEl.getAttribute('href');
              
              // JeÅ›li to link wewnÄ™trzny (zaczyna siÄ™ od /)
              if (href && href.startsWith('/')) {
                e.preventDefault();
                
                // UÅ¼ywamy naszej funkcji do nawigacji
                window.handleManualNavigation(href);
                return;
              }
            }
            targetEl = targetEl.parentElement;
          }
        });
      });
    </script>
  </body>
</html>
